<?xml version = '1.0' encoding = 'UTF-8'?>
<PackageOracle class="oracle.dbtools.crest.model.design.storage.oracle.PackageOracle" name="FLEX_WS_API" id="D7B7F0B8-CD2A-ED2E-CED4-798879217A50" directorySegmentName="seg_0">
<sourceConnName>DEV57_AXIONEUSER_FACTU</sourceConnName>
<sourceObjSchema>AXIONEUSER_FACTU</sourceObjSchema>
<sourceObjName>FLEX_WS_API</sourceObjName>
<createdBy>R.WATH</createdBy>
<createdTime>2012-12-04 10:06:38 UTC</createdTime>
<generatorID>Généré par l&apos;utilisateur</generatorID>
<ownerDesignName>ST-SYS-SIB-BD_FCTPRO-000009-8 MCD-FACTUPRO V4.5.0</ownerDesignName>
<owner>4FCC3A6A-181E-A36A-613B-7868309493E2</owner>
<source>CREATE OR REPLACE PACKAGE                    AXIONEUSER_FACTU.FLEX_WS_API &lt;br/&gt;as  &lt;br/&gt;  &lt;br/&gt;empty_vc_arr wwv_flow_global.vc_arr2;  &lt;br/&gt;  &lt;br/&gt;g_request_cookies   utl_http.cookie_table;  &lt;br/&gt;g_response_cookies  utl_http.cookie_table;  &lt;br/&gt;  &lt;br/&gt;type header is record (name varchar2(256), value varchar2(1024));  &lt;br/&gt;type header_table is table of header index by binary_integer;  &lt;br/&gt;  &lt;br/&gt;g_headers           header_table;  &lt;br/&gt;g_request_headers   header_table;  &lt;br/&gt;  &lt;br/&gt;g_status_code       pls_integer;  &lt;br/&gt;  &lt;br/&gt;  &lt;br/&gt;function blob2clobbase64 (  &lt;br/&gt;    p_blob in blob ) return clob;  &lt;br/&gt;  &lt;br/&gt;function clobbase642blob (  &lt;br/&gt;    p_clob in clob ) return blob;  &lt;br/&gt;  &lt;br/&gt;procedure make_request (  &lt;br/&gt;    p_url               in varchar2,  &lt;br/&gt;    p_action            in varchar2 default null,  &lt;br/&gt;    p_version           in varchar2 default &apos;1.1&apos;,  &lt;br/&gt;    p_collection_name   in varchar2 default null,  &lt;br/&gt;    p_envelope          in clob,  &lt;br/&gt;    p_username          in varchar2 default null,  &lt;br/&gt;    p_password          in varchar2 default null,  &lt;br/&gt;    p_proxy_override    in varchar2 default null,  &lt;br/&gt;    p_wallet_path       in varchar2 default null,  &lt;br/&gt;    p_wallet_pwd        in varchar2 default null,  &lt;br/&gt;    p_extra_headers     in wwv_flow_global.vc_arr2 default empty_vc_arr );  &lt;br/&gt;  &lt;br/&gt;function make_request (  &lt;br/&gt;    p_url               in varchar2,  &lt;br/&gt;    p_action            in varchar2 default null,  &lt;br/&gt;    p_version           in varchar2 default &apos;1.1&apos;,  &lt;br/&gt;    p_envelope          in clob,  &lt;br/&gt;    p_username          in varchar2 default null,  &lt;br/&gt;    p_password          in varchar2 default null,  &lt;br/&gt;    p_proxy_override    in varchar2 default null,  &lt;br/&gt;    p_wallet_path       in varchar2 default null,  &lt;br/&gt;    p_wallet_pwd        in varchar2 default null,  &lt;br/&gt;    p_extra_headers     in wwv_flow_global.vc_arr2 default empty_vc_arr ) return xmltype;  &lt;br/&gt;  &lt;br/&gt;function make_rest_request(  &lt;br/&gt;    p_url               in varchar2,  &lt;br/&gt;    p_http_method       in varchar2,  &lt;br/&gt;    p_username          in varchar2 default null,  &lt;br/&gt;    p_password          in varchar2 default null,  &lt;br/&gt;    p_proxy_override    in varchar2 default null,  &lt;br/&gt;    p_body              in clob default empty_clob(),  &lt;br/&gt;    p_body_blob         in blob default empty_blob(),  &lt;br/&gt;    p_parm_name         in wwv_flow_global.vc_arr2 default empty_vc_arr,  &lt;br/&gt;    p_parm_value        in wwv_flow_global.vc_arr2 default empty_vc_arr,  &lt;br/&gt;    p_http_headers      in wwv_flow_global.vc_arr2 default empty_vc_arr,  &lt;br/&gt;    p_http_hdr_values   in wwv_flow_global.vc_arr2 default empty_vc_arr,  &lt;br/&gt;    p_wallet_path       in varchar2 default null,  &lt;br/&gt;    p_wallet_pwd        in varchar2 default null ) return clob;  &lt;br/&gt;  &lt;br/&gt;function parse_xml (  &lt;br/&gt;    p_xml               in xmltype,  &lt;br/&gt;    p_xpath             in varchar2,  &lt;br/&gt;    p_ns                in varchar2 default null ) return varchar2;  &lt;br/&gt;  &lt;br/&gt;function parse_xml_clob (  &lt;br/&gt;    p_xml               in xmltype,  &lt;br/&gt;    p_xpath             in varchar2,  &lt;br/&gt;    p_ns                in varchar2 default null ) return clob;  &lt;br/&gt;  &lt;br/&gt;function parse_response (  &lt;br/&gt;    p_collection_name   in varchar2,  &lt;br/&gt;    p_xpath             in varchar2,  &lt;br/&gt;    p_ns                in varchar2 default null ) return varchar2;  &lt;br/&gt;  &lt;br/&gt;function parse_response_clob (  &lt;br/&gt;    p_collection_name   in varchar2,  &lt;br/&gt;    p_xpath             in varchar2,  &lt;br/&gt;    p_ns                in varchar2 default null ) return clob;  &lt;br/&gt;  &lt;br/&gt;end flex_ws_api;</source>
<body class="oracle.dbtools.crest.model.design.storage.oracle.PackageBodyOracle" name="FLEX_WS_API" id="D7B7F0B8-CD2A-ED2E-CED4-798879217A50">
<sourceConnName>DEV57_AXIONEUSER_FACTU</sourceConnName>
<sourceObjSchema>AXIONEUSER_FACTU</sourceObjSchema>
<sourceObjName>FLEX_WS_API</sourceObjName>
<createdBy>R.WATH</createdBy>
<createdTime>2012-12-04 10:06:39 UTC</createdTime>
<generatorID>Généré par l&apos;utilisateur</generatorID>
<owner>4FCC3A6A-181E-A36A-613B-7868309493E2</owner>
<source>CREATE OR REPLACE PACKAGE BODY                    AXIONEUSER_FACTU.FLEX_WS_API &lt;br/&gt;as  &lt;br/&gt;  &lt;br/&gt;function blob2clobbase64 (  &lt;br/&gt;    p_blob in blob ) return clob  &lt;br/&gt;is  &lt;br/&gt;    pos         pls_integer         := 1;  &lt;br/&gt;    buffer      varchar2 (32767);  &lt;br/&gt;    res         clob;  &lt;br/&gt;    lob_len     integer             := dbms_lob.getlength (p_blob);  &lt;br/&gt;    l_width     pls_integer         := (76 / 4 * 3)-9;  &lt;br/&gt;begin  &lt;br/&gt;    dbms_lob.createtemporary (res, true);  &lt;br/&gt;    dbms_lob.open (res, dbms_lob.lob_readwrite);  &lt;br/&gt;  &lt;br/&gt;    while (pos &lt; lob_len) loop  &lt;br/&gt;        buffer :=  &lt;br/&gt;                utl_raw.cast_to_varchar2  &lt;br/&gt;                 (utl_encode.base64_encode (dbms_lob.substr (p_blob, l_width, pos)));  &lt;br/&gt;  &lt;br/&gt;        dbms_lob.writeappend (res, length (buffer), buffer);  &lt;br/&gt;  &lt;br/&gt;        pos := pos + l_width;  &lt;br/&gt;    end loop;  &lt;br/&gt;  &lt;br/&gt;    return res;  &lt;br/&gt;  &lt;br/&gt;end blob2clobbase64;  &lt;br/&gt;  &lt;br/&gt;function clobbase642blob (  &lt;br/&gt;    p_clob in clob ) return blob  &lt;br/&gt;is  &lt;br/&gt;    pos         pls_integer         := 1;  &lt;br/&gt;    buffer      raw(36);  &lt;br/&gt;    res         blob;  &lt;br/&gt;    lob_len     integer             := dbms_lob.getlength (p_clob);  &lt;br/&gt;    l_width     pls_integer         := (76 / 4 * 3)-9;  &lt;br/&gt;begin  &lt;br/&gt;    dbms_lob.createtemporary (res, true);  &lt;br/&gt;    dbms_lob.open (res, dbms_lob.lob_readwrite);  &lt;br/&gt;  &lt;br/&gt;    while (pos &lt; lob_len) loop  &lt;br/&gt;        buffer := utl_encode.base64_decode(utl_raw.cast_to_raw(dbms_lob.substr (p_clob, l_width, pos)));  &lt;br/&gt;  &lt;br/&gt;        dbms_lob.writeappend (res, utl_raw.length(buffer), buffer);  &lt;br/&gt;  &lt;br/&gt;        pos := pos + l_width;  &lt;br/&gt;    end loop;  &lt;br/&gt;  &lt;br/&gt;    return res;  &lt;br/&gt;  &lt;br/&gt;end clobbase642blob;  &lt;br/&gt;  &lt;br/&gt;procedure make_request (  &lt;br/&gt;    p_url               in varchar2,  &lt;br/&gt;    p_action            in varchar2 default null,  &lt;br/&gt;    p_version           in varchar2 default &apos;1.1&apos;,  &lt;br/&gt;    p_collection_name   in varchar2 default null,  &lt;br/&gt;    p_envelope          in clob,  &lt;br/&gt;    p_username          in varchar2 default null,  &lt;br/&gt;    p_password          in varchar2 default null,  &lt;br/&gt;    p_proxy_override    in varchar2 default null,  &lt;br/&gt;    p_wallet_path       in varchar2 default null,  &lt;br/&gt;    p_wallet_pwd        in varchar2 default null,  &lt;br/&gt;    p_extra_headers     in wwv_flow_global.vc_arr2 default empty_vc_arr )  &lt;br/&gt;is  &lt;br/&gt;    l_clob clob;  &lt;br/&gt;    l_http_req utl_http.req;  &lt;br/&gt;    l_http_resp utl_http.resp;  &lt;br/&gt;    l_amount binary_integer := 8000;  &lt;br/&gt;    l_offset integer := 1;  &lt;br/&gt;    l_buffer varchar2(32000);  &lt;br/&gt;    l_db_charset   varchar2(100);  &lt;br/&gt;    l_env_lenb integer := 0;  &lt;br/&gt;    i integer := 0;  &lt;br/&gt;    l_headers wwv_flow_global.vc_arr2;  &lt;br/&gt;    l_response varchar2(2000);  &lt;br/&gt;    l_name          varchar2(256);  &lt;br/&gt;    l_hdr_value     varchar2(1024);  &lt;br/&gt;    l_hdr           header;  &lt;br/&gt;    l_hdrs          header_table;  &lt;br/&gt;begin  &lt;br/&gt;  &lt;br/&gt;    -- determine database characterset, if not AL32UTF8, conversion will be necessary  &lt;br/&gt;    select value into l_db_charset from nls_database_parameters where parameter=&apos;NLS_CHARACTERSET&apos;;  &lt;br/&gt;  &lt;br/&gt;    -- determine length for content-length header  &lt;br/&gt;    loop  &lt;br/&gt;        exit when wwv_flow_utilities.clob_to_varchar2(p_envelope,i*32767) is null;  &lt;br/&gt;        if l_db_charset = &apos;AL32UTF8&apos; then  &lt;br/&gt;            l_env_lenb := l_env_lenb + lengthb(wwv_flow_utilities.clob_to_varchar2(p_envelope,i*32767));  &lt;br/&gt;        else  &lt;br/&gt;            l_env_lenb := l_env_lenb + utl_raw.length(  &lt;br/&gt;                    utl_raw.convert(utl_raw.cast_to_raw(wwv_flow_utilities.clob_to_varchar2(p_envelope,i*32767)),  &lt;br/&gt;                        &apos;american_america.al32utf8&apos;,&apos;american_america.&apos;||l_db_charset));  &lt;br/&gt;        end if;  &lt;br/&gt;        i := i + 1;  &lt;br/&gt;    end loop;  &lt;br/&gt;  &lt;br/&gt;    -- set a proxy if required  &lt;br/&gt;    if apex_application.g_proxy_server is not null and p_proxy_override is null then  &lt;br/&gt;        utl_http.set_proxy (proxy =&gt; apex_application.g_proxy_server);  &lt;br/&gt;    elsif p_proxy_override is not null then  &lt;br/&gt;        utl_http.set_proxy (proxy =&gt; p_proxy_override);  &lt;br/&gt;    end if;  &lt;br/&gt;  &lt;br/&gt;    utl_http.set_persistent_conn_support(true);  &lt;br/&gt;    utl_http.set_transfer_timeout(600);  &lt;br/&gt;  &lt;br/&gt;    -- set wallet if necessary  &lt;br/&gt;    if instr(lower(p_url),&apos;https&apos;) = 1 then  &lt;br/&gt;        utl_http.set_wallet(p_wallet_path, p_wallet_pwd);  &lt;br/&gt;    end if;  &lt;br/&gt;  &lt;br/&gt;    -- set cookies if necessary  &lt;br/&gt;    begin  &lt;br/&gt;        if g_request_cookies.count &gt; 0 then  &lt;br/&gt;            utl_http.clear_cookies;  &lt;br/&gt;            utl_http.add_cookies(g_request_cookies);  &lt;br/&gt;        end if;  &lt;br/&gt;    exception when others then  &lt;br/&gt;        raise_application_error(-20001,&apos;The provided cookie is invalid.&apos;);  &lt;br/&gt;    end;  &lt;br/&gt;  &lt;br/&gt;    -- begin the request  &lt;br/&gt;    if wwv_flow_utilities.db_version like &apos;9.%&apos; then  &lt;br/&gt;        l_http_req := utl_http.begin_request(p_url, &apos;POST&apos;, &apos;HTTP/1.0&apos;);  &lt;br/&gt;    else  &lt;br/&gt;        l_http_req := utl_http.begin_request(p_url, &apos;POST&apos;);  &lt;br/&gt;    end if;  &lt;br/&gt;  &lt;br/&gt;    -- set basic authentication if required  &lt;br/&gt;    if p_username is not null then  &lt;br/&gt;        utl_http.set_authentication (  &lt;br/&gt;            r =&gt; l_http_req,  &lt;br/&gt;            username =&gt; p_username,  &lt;br/&gt;            password =&gt; p_password,  &lt;br/&gt;            scheme =&gt; &apos;Basic&apos;,  &lt;br/&gt;            for_proxy =&gt; false );  &lt;br/&gt;    end if;  &lt;br/&gt;  &lt;br/&gt;    -- set standard HTTP headers for a SOAP request  &lt;br/&gt;    utl_http.set_header(l_http_req, &apos;Proxy-Connection&apos;, &apos;Keep-Alive&apos;);  &lt;br/&gt;    if p_version = &apos;1.2&apos; then  &lt;br/&gt;        utl_http.set_header(l_http_req, &apos;Content-Type&apos;, &apos;application/soap+xml; charset=UTF-8; action=&quot;&apos;||p_action||&apos;&quot;;&apos;);  &lt;br/&gt;    else  &lt;br/&gt;        utl_http.set_header(l_http_req, &apos;SOAPAction&apos;, p_action);  &lt;br/&gt;        utl_http.set_header(l_http_req, &apos;Content-Type&apos;, &apos;text/xml; charset=UTF-8&apos;);  &lt;br/&gt;    end if;  &lt;br/&gt;    utl_http.set_header(l_http_req, &apos;Content-Length&apos;, l_env_lenb);  &lt;br/&gt;  &lt;br/&gt;    -- set additional headers if supplied, these are separated by a colon (:) as name/value pairs  &lt;br/&gt;    for i in 1.. p_extra_headers.count loop  &lt;br/&gt;        l_headers := apex_util.string_to_table(p_extra_headers(i));  &lt;br/&gt;        utl_http.set_header(l_http_req, l_headers(1), l_headers(2));  &lt;br/&gt;    end loop;  &lt;br/&gt;  &lt;br/&gt;    --set headers from g_request_headers  &lt;br/&gt;    for i in 1.. g_request_headers.count loop  &lt;br/&gt;        utl_http.set_header(l_http_req, g_request_headers(i).name, g_request_headers(i).value);  &lt;br/&gt;    end loop;  &lt;br/&gt;  &lt;br/&gt;    -- read the envelope, convert to UTF8 if necessary, then write it to the HTTP request  &lt;br/&gt;    begin  &lt;br/&gt;        loop  &lt;br/&gt;            dbms_lob.read( p_envelope, l_amount, l_offset, l_buffer );  &lt;br/&gt;            if l_db_charset = &apos;AL32UTF8&apos; then  &lt;br/&gt;                utl_http.write_text(l_http_req, l_buffer);  &lt;br/&gt;            else  &lt;br/&gt;                utl_http.write_raw(l_http_req,utl_raw.convert(utl_raw.cast_to_raw(l_buffer),&apos;american_america.al32utf8&apos;,&apos;american_america.&apos;||l_db_charset));  &lt;br/&gt;            end if;  &lt;br/&gt;            l_offset := l_offset + l_amount;  &lt;br/&gt;            l_amount := 8000;  &lt;br/&gt;        end loop;  &lt;br/&gt;    exception  &lt;br/&gt;        when no_data_found then  &lt;br/&gt;            null;  &lt;br/&gt;    end;  &lt;br/&gt;  &lt;br/&gt;    -- get the response  &lt;br/&gt;    l_http_resp := utl_http.get_response(l_http_req);  &lt;br/&gt;  &lt;br/&gt;    -- set response code, response http header and response cookies global  &lt;br/&gt;    g_status_code := l_http_resp.status_code;  &lt;br/&gt;    utl_http.get_cookies(g_response_cookies);  &lt;br/&gt;    for i in 1..utl_http.get_header_count(l_http_resp) loop  &lt;br/&gt;        utl_http.get_header(l_http_resp, i, l_name, l_hdr_value);  &lt;br/&gt;        l_hdr.name := l_name;  &lt;br/&gt;        l_hdr.value := l_hdr_value;  &lt;br/&gt;        l_hdrs(i) := l_hdr;  &lt;br/&gt;    end loop;  &lt;br/&gt;  &lt;br/&gt;    g_headers := l_hdrs;  &lt;br/&gt;  &lt;br/&gt;    -- put the response in a collection if necessary  &lt;br/&gt;    if p_collection_name is not null then  &lt;br/&gt;  &lt;br/&gt;        apex_collection.create_or_truncate_collection(p_collection_name);  &lt;br/&gt;  &lt;br/&gt;        dbms_lob.createtemporary( l_clob, FALSE );  &lt;br/&gt;        dbms_lob.open( l_clob, dbms_lob.lob_readwrite );  &lt;br/&gt;        begin  &lt;br/&gt;            loop  &lt;br/&gt;                utl_http.read_text(l_http_resp, l_buffer);  &lt;br/&gt;                dbms_lob.writeappend( l_clob, length(l_buffer), l_buffer );  &lt;br/&gt;            end loop;  &lt;br/&gt;        exception  &lt;br/&gt;            when others then  &lt;br/&gt;                if sqlcode &lt;&gt; -29266 then  &lt;br/&gt;                    raise;  &lt;br/&gt;                end if;  &lt;br/&gt;        end;  &lt;br/&gt;  &lt;br/&gt;        apex_collection.add_member(  &lt;br/&gt;            p_collection_name   =&gt; p_collection_name,  &lt;br/&gt;            p_clob001           =&gt; l_clob);  &lt;br/&gt;    end if;  &lt;br/&gt;    --  &lt;br/&gt;    utl_http.end_response(l_http_resp);  &lt;br/&gt;  &lt;br/&gt;end make_request;  &lt;br/&gt;  &lt;br/&gt;function make_request (  &lt;br/&gt;    p_url               in varchar2,  &lt;br/&gt;    p_action            in varchar2 default null,  &lt;br/&gt;    p_version           in varchar2 default &apos;1.1&apos;,  &lt;br/&gt;    p_envelope          in clob,  &lt;br/&gt;    p_username          in varchar2 default null,  &lt;br/&gt;    p_password          in varchar2 default null,  &lt;br/&gt;    p_proxy_override    in varchar2 default null,  &lt;br/&gt;    p_wallet_path       in varchar2 default null,  &lt;br/&gt;    p_wallet_pwd        in varchar2 default null,  &lt;br/&gt;    p_extra_headers     in wwv_flow_global.vc_arr2 default empty_vc_arr ) return xmltype  &lt;br/&gt;is  &lt;br/&gt;    l_clob clob;  &lt;br/&gt;    l_http_req utl_http.req;  &lt;br/&gt;    l_http_resp utl_http.resp;  &lt;br/&gt;    l_amount binary_integer := 8000;  &lt;br/&gt;    l_offset integer := 1;  &lt;br/&gt;    l_buffer varchar2(32000);  &lt;br/&gt;    l_db_charset   varchar2(100);  &lt;br/&gt;    l_env_lenb integer := 0;  &lt;br/&gt;    i integer := 0;  &lt;br/&gt;    l_headers wwv_flow_global.vc_arr2;  &lt;br/&gt;    l_response varchar2(2000);  &lt;br/&gt;    l_name          varchar2(256);  &lt;br/&gt;    l_hdr_value     varchar2(1024);  &lt;br/&gt;    l_hdr           header;  &lt;br/&gt;    l_hdrs          header_table;  &lt;br/&gt;begin  &lt;br/&gt;  &lt;br/&gt;    -- determine database characterset, if not AL32UTF8, conversion will be necessary  &lt;br/&gt;    select value into l_db_charset from nls_database_parameters where parameter=&apos;NLS_CHARACTERSET&apos;;  &lt;br/&gt;  &lt;br/&gt;    -- determine length for content-length header  &lt;br/&gt;    loop  &lt;br/&gt;        exit when wwv_flow_utilities.clob_to_varchar2(p_envelope,i*32767) is null;  &lt;br/&gt;        if l_db_charset = &apos;AL32UTF8&apos; then  &lt;br/&gt;            l_env_lenb := l_env_lenb + lengthb(wwv_flow_utilities.clob_to_varchar2(p_envelope,i*32767));  &lt;br/&gt;        else  &lt;br/&gt;            l_env_lenb := l_env_lenb + utl_raw.length(  &lt;br/&gt;                    utl_raw.convert(utl_raw.cast_to_raw(wwv_flow_utilities.clob_to_varchar2(p_envelope,i*32767)),  &lt;br/&gt;                        &apos;american_america.al32utf8&apos;,&apos;american_america.&apos;||l_db_charset));  &lt;br/&gt;        end if;  &lt;br/&gt;        i := i + 1;  &lt;br/&gt;    end loop;  &lt;br/&gt;  &lt;br/&gt;    -- set a proxy if required  &lt;br/&gt;    if apex_application.g_proxy_server is not null and p_proxy_override is null then  &lt;br/&gt;        utl_http.set_proxy (proxy =&gt; apex_application.g_proxy_server);  &lt;br/&gt;    elsif p_proxy_override is not null then  &lt;br/&gt;        utl_http.set_proxy (proxy =&gt; p_proxy_override);  &lt;br/&gt;    end if;  &lt;br/&gt;  &lt;br/&gt;    utl_http.set_persistent_conn_support(true);  &lt;br/&gt;    utl_http.set_transfer_timeout(600);  &lt;br/&gt;  &lt;br/&gt;    -- set wallet if necessary  &lt;br/&gt;    if instr(lower(p_url),&apos;https&apos;) = 1 then  &lt;br/&gt;        utl_http.set_wallet(p_wallet_path, p_wallet_pwd);  &lt;br/&gt;    end if;  &lt;br/&gt;  &lt;br/&gt;    -- set cookies if necessary  &lt;br/&gt;    begin  &lt;br/&gt;        if g_request_cookies.count &gt; 0 then  &lt;br/&gt;            utl_http.clear_cookies;  &lt;br/&gt;            utl_http.add_cookies(g_request_cookies);  &lt;br/&gt;        end if;  &lt;br/&gt;    exception when others then  &lt;br/&gt;        raise_application_error(-20001,&apos;The provided cookie is invalid.&apos;);  &lt;br/&gt;    end;  &lt;br/&gt;  &lt;br/&gt;    -- begin the request  &lt;br/&gt;    if wwv_flow_utilities.db_version like &apos;9.%&apos; then  &lt;br/&gt;        l_http_req := utl_http.begin_request(p_url, &apos;POST&apos;, &apos;HTTP/1.0&apos;);  &lt;br/&gt;    else  &lt;br/&gt;        l_http_req := utl_http.begin_request(p_url, &apos;POST&apos;);  &lt;br/&gt;    end if;  &lt;br/&gt;  &lt;br/&gt;    -- set basic authentication if required  &lt;br/&gt;    if p_username is not null then  &lt;br/&gt;        utl_http.set_authentication (  &lt;br/&gt;            r =&gt; l_http_req,  &lt;br/&gt;            username =&gt; p_username,  &lt;br/&gt;            password =&gt; p_password,  &lt;br/&gt;            scheme =&gt; &apos;Basic&apos;,  &lt;br/&gt;            for_proxy =&gt; false );  &lt;br/&gt;    end if;  &lt;br/&gt;  &lt;br/&gt;    -- set standard HTTP headers for a SOAP request  &lt;br/&gt;    utl_http.set_header(l_http_req, &apos;Proxy-Connection&apos;, &apos;Keep-Alive&apos;);  &lt;br/&gt;    if p_version = &apos;1.2&apos; then  &lt;br/&gt;        utl_http.set_header(l_http_req, &apos;Content-Type&apos;, &apos;application/soap+xml; charset=UTF-8; action=&quot;&apos;||p_action||&apos;&quot;;&apos;);  &lt;br/&gt;    else  &lt;br/&gt;        utl_http.set_header(l_http_req, &apos;SOAPAction&apos;, p_action);  &lt;br/&gt;        utl_http.set_header(l_http_req, &apos;Content-Type&apos;, &apos;text/xml; charset=UTF-8&apos;);  &lt;br/&gt;    end if;  &lt;br/&gt;    utl_http.set_header(l_http_req, &apos;Content-Length&apos;, l_env_lenb);  &lt;br/&gt;  &lt;br/&gt;    -- set additional headers if supplied, these are separated by a colon (:) as name/value pairs  &lt;br/&gt;    for i in 1.. p_extra_headers.count loop  &lt;br/&gt;        l_headers := apex_util.string_to_table(p_extra_headers(i));  &lt;br/&gt;        utl_http.set_header(l_http_req, l_headers(1), l_headers(2));  &lt;br/&gt;    end loop;  &lt;br/&gt;  &lt;br/&gt;    --set headers from g_request_headers  &lt;br/&gt;    for i in 1.. g_request_headers.count loop  &lt;br/&gt;        utl_http.set_header(l_http_req, g_request_headers(i).name, g_request_headers(i).value);  &lt;br/&gt;    end loop;  &lt;br/&gt;  &lt;br/&gt;    -- read the envelope, convert to UTF8 if necessary, then write it to the HTTP request  &lt;br/&gt;    begin  &lt;br/&gt;        loop  &lt;br/&gt;            dbms_lob.read( p_envelope, l_amount, l_offset, l_buffer );  &lt;br/&gt;            if l_db_charset = &apos;AL32UTF8&apos; then  &lt;br/&gt;                utl_http.write_text(l_http_req, l_buffer);  &lt;br/&gt;            else  &lt;br/&gt;                utl_http.write_raw(l_http_req,utl_raw.convert(utl_raw.cast_to_raw(l_buffer),&apos;american_america.al32utf8&apos;,&apos;american_america.&apos;||l_db_charset));  &lt;br/&gt;            end if;  &lt;br/&gt;            l_offset := l_offset + l_amount;  &lt;br/&gt;            l_amount := 8000;  &lt;br/&gt;        end loop;  &lt;br/&gt;    exception  &lt;br/&gt;        when no_data_found then  &lt;br/&gt;            null;  &lt;br/&gt;    end;  &lt;br/&gt;  &lt;br/&gt;    -- get the response  &lt;br/&gt;    l_http_resp := utl_http.get_response(l_http_req);  &lt;br/&gt;  &lt;br/&gt;    -- set response code, response http header and response cookies global  &lt;br/&gt;    g_status_code := l_http_resp.status_code;  &lt;br/&gt;    utl_http.get_cookies(g_response_cookies);  &lt;br/&gt;    for i in 1..utl_http.get_header_count(l_http_resp) loop  &lt;br/&gt;        utl_http.get_header(l_http_resp, i, l_name, l_hdr_value);  &lt;br/&gt;        l_hdr.name := l_name;  &lt;br/&gt;        l_hdr.value := l_hdr_value;  &lt;br/&gt;        l_hdrs(i) := l_hdr;  &lt;br/&gt;    end loop;  &lt;br/&gt;  &lt;br/&gt;    g_headers := l_hdrs;  &lt;br/&gt;  &lt;br/&gt;    -- put the response in a clob  &lt;br/&gt;    dbms_lob.createtemporary( l_clob, FALSE );  &lt;br/&gt;    dbms_lob.open( l_clob, dbms_lob.lob_readwrite );  &lt;br/&gt;    begin  &lt;br/&gt;        loop  &lt;br/&gt;            utl_http.read_text(l_http_resp, l_buffer);  &lt;br/&gt;            dbms_lob.writeappend( l_clob, length(l_buffer), l_buffer );  &lt;br/&gt;        end loop;  &lt;br/&gt;    exception  &lt;br/&gt;        when others then  &lt;br/&gt;            if sqlcode &lt;&gt; -29266 then  &lt;br/&gt;                raise;  &lt;br/&gt;            end if;  &lt;br/&gt;    end;  &lt;br/&gt;  &lt;br/&gt;    utl_http.end_response(l_http_resp);  &lt;br/&gt;  &lt;br/&gt;    return xmltype.createxml(l_clob);  &lt;br/&gt;  &lt;br/&gt;exception when others then  &lt;br/&gt;    if sqlcode = -31011 then -- its not xml  &lt;br/&gt;        return null;  &lt;br/&gt;    end if;  &lt;br/&gt;end make_request;  &lt;br/&gt;  &lt;br/&gt;function make_rest_request(  &lt;br/&gt;    p_url               in varchar2,  &lt;br/&gt;    p_http_method       in varchar2,  &lt;br/&gt;    p_username          in varchar2 default null,  &lt;br/&gt;    p_password          in varchar2 default null,  &lt;br/&gt;    p_proxy_override    in varchar2 default null,  &lt;br/&gt;    p_body              in clob default empty_clob(),  &lt;br/&gt;    p_body_blob         in blob default empty_blob(),  &lt;br/&gt;    p_parm_name         in wwv_flow_global.vc_arr2 default empty_vc_arr,  &lt;br/&gt;    p_parm_value        in wwv_flow_global.vc_arr2 default empty_vc_arr,  &lt;br/&gt;    p_http_headers      in wwv_flow_global.vc_arr2 default empty_vc_arr,  &lt;br/&gt;    p_http_hdr_values   in wwv_flow_global.vc_arr2 default empty_vc_arr,  &lt;br/&gt;    p_wallet_path       in varchar2 default null,  &lt;br/&gt;    p_wallet_pwd        in varchar2 default null )  &lt;br/&gt;return clob  &lt;br/&gt;is  &lt;br/&gt;    l_http_req      utl_http.req;  &lt;br/&gt;    l_http_resp     utl_http.resp;  &lt;br/&gt;    --  &lt;br/&gt;    l_body          clob default empty_clob();  &lt;br/&gt;    i               integer;  &lt;br/&gt;    l_env_lenb      number  := 0;  &lt;br/&gt;    l_db_charset    varchar2(100) := &apos;AL32UTF8&apos;;  &lt;br/&gt;    l_buffer        varchar2(32767);  &lt;br/&gt;    l_raw           raw(48);  &lt;br/&gt;    l_amount        number;  &lt;br/&gt;    l_offset        number;  &lt;br/&gt;    l_value         clob;  &lt;br/&gt;    l_url           varchar2(32767);  &lt;br/&gt;    l_parm_value    varchar2(32767);  &lt;br/&gt;    l_name          varchar2(256);  &lt;br/&gt;    l_hdr_value     varchar2(1024);  &lt;br/&gt;    l_hdr           header;  &lt;br/&gt;    l_hdrs          header_table;  &lt;br/&gt;begin  &lt;br/&gt;  &lt;br/&gt;    -- determine database characterset, if not AL32UTF8, conversion will be necessary  &lt;br/&gt;    select value into l_db_charset from nls_database_parameters where parameter=&apos;NLS_CHARACTERSET&apos;;  &lt;br/&gt;  &lt;br/&gt;    -- set a proxy if required  &lt;br/&gt;    if apex_application.g_proxy_server is not null and p_proxy_override is null then  &lt;br/&gt;        utl_http.set_proxy (proxy =&gt; apex_application.g_proxy_server);  &lt;br/&gt;    elsif p_proxy_override is not null then  &lt;br/&gt;        utl_http.set_proxy (proxy =&gt; p_proxy_override);  &lt;br/&gt;    end if;  &lt;br/&gt;  &lt;br/&gt;    utl_http.set_persistent_conn_support(TRUE);  &lt;br/&gt;    utl_http.set_transfer_timeout(180);  &lt;br/&gt;  &lt;br/&gt;    if instr(lower(p_url),&apos;https&apos;) = 1 then  &lt;br/&gt;        utl_http.set_wallet(p_wallet_path, p_wallet_pwd);  &lt;br/&gt;    end if;  &lt;br/&gt;  &lt;br/&gt;    if dbms_lob.getlength(p_body) = 0 then  &lt;br/&gt;        for i in 1.. p_parm_name.count loop  &lt;br/&gt;            if p_http_method = &apos;GET&apos; then  &lt;br/&gt;                l_parm_value := apex_util.url_encode(p_parm_value(i));  &lt;br/&gt;            else  &lt;br/&gt;                l_parm_value := p_parm_value(i);  &lt;br/&gt;            end if;  &lt;br/&gt;            if i = 1 then  &lt;br/&gt;                l_body := p_parm_name(i)||&apos;=&apos;||l_parm_value;  &lt;br/&gt;            else  &lt;br/&gt;                l_body := l_body||&apos;&amp;&apos;||p_parm_name(i)||&apos;=&apos;||l_parm_value;  &lt;br/&gt;            end if;  &lt;br/&gt;        end loop;  &lt;br/&gt;    else  &lt;br/&gt;        l_body := p_body;  &lt;br/&gt;    end if;  &lt;br/&gt;  &lt;br/&gt;    i := 0;  &lt;br/&gt;  &lt;br/&gt;    l_url := p_url;  &lt;br/&gt;  &lt;br/&gt;    if p_http_method = &apos;GET&apos; then  &lt;br/&gt;        l_url := l_url||&apos;?&apos;||wwv_flow_utilities.clob_to_varchar2(l_body);  &lt;br/&gt;    end if;  &lt;br/&gt;  &lt;br/&gt;    -- determine length in bytes of l_body;  &lt;br/&gt;    if dbms_lob.getlength(p_body_blob) &gt; 0 then  &lt;br/&gt;        l_env_lenb := dbms_lob.getlength(p_body_blob);  &lt;br/&gt;    else  &lt;br/&gt;        loop  &lt;br/&gt;            exit when wwv_flow_utilities.clob_to_varchar2(l_body,i*32767) is null;  &lt;br/&gt;            if l_db_charset = &apos;AL32UTF8&apos; then  &lt;br/&gt;                l_env_lenb := l_env_lenb + lengthb(wwv_flow_utilities.clob_to_varchar2(l_body,i*32767));  &lt;br/&gt;            else  &lt;br/&gt;                l_env_lenb := l_env_lenb + utl_raw.length(  &lt;br/&gt;                    utl_raw.convert(utl_raw.cast_to_raw(wwv_flow_utilities.clob_to_varchar2(l_body,i*32767)),  &lt;br/&gt;                        &apos;american_america.al32utf8&apos;,&apos;american_america.&apos; || l_db_charset));  &lt;br/&gt;            end if;  &lt;br/&gt;            i := i + 1;  &lt;br/&gt;        end loop;  &lt;br/&gt;    end if;  &lt;br/&gt;  &lt;br/&gt;    -- set cookies if necessary  &lt;br/&gt;    begin  &lt;br/&gt;        if g_request_cookies.count &gt; 0 then  &lt;br/&gt;            utl_http.clear_cookies;  &lt;br/&gt;            utl_http.add_cookies(g_request_cookies);  &lt;br/&gt;        end if;  &lt;br/&gt;    exception when others then  &lt;br/&gt;        raise_application_error(-20001,&apos;The provided cookie is invalid.&apos;);  &lt;br/&gt;    end;  &lt;br/&gt;  &lt;br/&gt;    begin  &lt;br/&gt;        l_http_req := utl_http.begin_request(l_url, p_http_method);  &lt;br/&gt;        -- set basic authentication if necessary  &lt;br/&gt;        if p_username is not null then  &lt;br/&gt;             utl_http.set_authentication(l_http_req, p_username, p_password);  &lt;br/&gt;        end if;  &lt;br/&gt;        utl_http.set_header(l_http_req, &apos;Proxy-Connection&apos;, &apos;Keep-Alive&apos;);  &lt;br/&gt;        if p_http_method != &apos;GET&apos; then  &lt;br/&gt;            utl_http.set_header(l_http_req, &apos;Content-Length&apos;, l_env_lenb);  &lt;br/&gt;        end if;  &lt;br/&gt;        -- set additional headers if supplied, these are separated by a colon (:) as name/value pairs  &lt;br/&gt;        for i in 1.. p_http_headers.count loop  &lt;br/&gt;            utl_http.set_header(l_http_req, p_http_headers(i), p_http_hdr_values(i));  &lt;br/&gt;        end loop;  &lt;br/&gt;    exception when others then  &lt;br/&gt;        raise_application_error(-20001,&apos;The URL provided is invalid or you need to set a proxy.&apos;);  &lt;br/&gt;    end;  &lt;br/&gt;  &lt;br/&gt;    --set headers from g_request_headers  &lt;br/&gt;    for i in 1.. g_request_headers.count loop  &lt;br/&gt;        utl_http.set_header(l_http_req, g_request_headers(i).name, g_request_headers(i).value);  &lt;br/&gt;    end loop;  &lt;br/&gt;  &lt;br/&gt;    --  &lt;br/&gt;    l_amount := 8000;  &lt;br/&gt;    l_offset := 1;  &lt;br/&gt;    if p_http_method != &apos;GET&apos; then  &lt;br/&gt;        if dbms_lob.getlength(l_body) &gt; 0 then  &lt;br/&gt;            begin  &lt;br/&gt;                loop  &lt;br/&gt;                    dbms_lob.read( l_body, l_amount, l_offset, l_buffer );  &lt;br/&gt;                    if l_db_charset = &apos;AL32UTF8&apos; then  &lt;br/&gt;                        utl_http.write_text(l_http_req, l_buffer);  &lt;br/&gt;                    else  &lt;br/&gt;                        utl_http.write_raw(l_http_req,  &lt;br/&gt;                                           utl_raw.convert(utl_raw.cast_to_raw(l_buffer),  &lt;br/&gt;                                                           &apos;american_america.al32utf8&apos;,  &lt;br/&gt;                                                           &apos;american_america.&apos; || l_db_charset  &lt;br/&gt;                                       )  &lt;br/&gt;                        );  &lt;br/&gt;                    end if;  &lt;br/&gt;                    l_offset := l_offset + l_amount;  &lt;br/&gt;                    l_amount := 8000;  &lt;br/&gt;                end loop;  &lt;br/&gt;            exception  &lt;br/&gt;                when no_data_found then  &lt;br/&gt;                    null;  &lt;br/&gt;            end;  &lt;br/&gt;        elsif dbms_lob.getlength(p_body_blob) &gt; 0 then  &lt;br/&gt;            begin  &lt;br/&gt;                l_amount := 48;  &lt;br/&gt;                while (l_offset &lt; l_env_lenb) loop  &lt;br/&gt;                    dbms_lob.read(p_body_blob, l_amount, l_offset, l_raw);  &lt;br/&gt;                    utl_http.write_raw(l_http_req, l_raw);  &lt;br/&gt;                    l_offset := l_offset + l_amount;  &lt;br/&gt;                end loop;  &lt;br/&gt;            exception  &lt;br/&gt;                when no_data_found then  &lt;br/&gt;                    null;  &lt;br/&gt;            end;  &lt;br/&gt;        end if;  &lt;br/&gt;    end if;  &lt;br/&gt;    --  &lt;br/&gt;    begin  &lt;br/&gt;        l_http_resp := utl_http.get_response(l_http_req);  &lt;br/&gt;    exception when others then  &lt;br/&gt;        raise_application_error(-20001,&apos;The URL provided is invalid or you need to set a proxy.&apos;);  &lt;br/&gt;    end;  &lt;br/&gt;    --  &lt;br/&gt;  &lt;br/&gt;    -- set response code, response http header and response cookies global  &lt;br/&gt;    g_status_code := l_http_resp.status_code;  &lt;br/&gt;    utl_http.get_cookies(g_response_cookies);  &lt;br/&gt;    for i in 1..utl_http.get_header_count(l_http_resp) loop  &lt;br/&gt;        utl_http.get_header(l_http_resp, i, l_name, l_hdr_value);  &lt;br/&gt;        l_hdr.name := l_name;  &lt;br/&gt;        l_hdr.value := l_hdr_value;  &lt;br/&gt;        l_hdrs(i) := l_hdr;  &lt;br/&gt;    end loop;  &lt;br/&gt;  &lt;br/&gt;    g_headers := l_hdrs;  &lt;br/&gt;  &lt;br/&gt;    --  &lt;br/&gt;    dbms_lob.createtemporary( l_value, FALSE );  &lt;br/&gt;    dbms_lob.open( l_value, dbms_lob.lob_readwrite );  &lt;br/&gt;  &lt;br/&gt;    begin  &lt;br/&gt;        loop  &lt;br/&gt;            utl_http.read_text(l_http_resp, l_buffer);  &lt;br/&gt;            dbms_lob.writeappend( l_value, length(l_buffer), l_buffer );  &lt;br/&gt;        end loop;  &lt;br/&gt;    exception  &lt;br/&gt;        when others then  &lt;br/&gt;            if sqlcode &lt;&gt; -29266 then  &lt;br/&gt;                raise;  &lt;br/&gt;            end if;  &lt;br/&gt;    end;  &lt;br/&gt;    --  &lt;br/&gt;    utl_http.end_response(l_http_resp);  &lt;br/&gt;  &lt;br/&gt;    return l_value;  &lt;br/&gt;  &lt;br/&gt;end make_rest_request;  &lt;br/&gt;  &lt;br/&gt;function parse_xml (  &lt;br/&gt;    p_xml               in xmltype,  &lt;br/&gt;    p_xpath             in varchar2,  &lt;br/&gt;    p_ns                in varchar2 default null ) return varchar2  &lt;br/&gt;is  &lt;br/&gt;    l_response          varchar2(32767);  &lt;br/&gt;begin  &lt;br/&gt;  &lt;br/&gt;    l_response := dbms_xmlgen.convert(p_xml.extract(p_xpath,p_ns).getstringval(),1);  &lt;br/&gt;  &lt;br/&gt;    return l_response;  &lt;br/&gt;  &lt;br/&gt;exception when others then  &lt;br/&gt;    if sqlcode = -30625 then -- path not found  &lt;br/&gt;        return null;  &lt;br/&gt;    end if;  &lt;br/&gt;end parse_xml;  &lt;br/&gt;  &lt;br/&gt;function parse_xml_clob (  &lt;br/&gt;    p_xml               in xmltype,  &lt;br/&gt;    p_xpath             in varchar2,  &lt;br/&gt;    p_ns                in varchar2 default null ) return clob  &lt;br/&gt;is  &lt;br/&gt;    l_response          clob;  &lt;br/&gt;begin  &lt;br/&gt;  &lt;br/&gt;    l_response := p_xml.extract(p_xpath,p_ns).getclobval();  &lt;br/&gt;  &lt;br/&gt;    return l_response;  &lt;br/&gt;  &lt;br/&gt;exception when others then  &lt;br/&gt;    if sqlcode = -30625 then -- path not found  &lt;br/&gt;        return null;  &lt;br/&gt;    end if;  &lt;br/&gt;end parse_xml_clob;  &lt;br/&gt;  &lt;br/&gt;function parse_response (  &lt;br/&gt;    p_collection_name   in varchar2,  &lt;br/&gt;    p_xpath             in varchar2,  &lt;br/&gt;    p_ns                in varchar2 default null ) return varchar2  &lt;br/&gt;is  &lt;br/&gt;    l_response          varchar2(32767);  &lt;br/&gt;    l_xml               xmltype;  &lt;br/&gt;begin  &lt;br/&gt;  &lt;br/&gt;    for c1 in (select clob001  &lt;br/&gt;                 from apex_collections  &lt;br/&gt;                where collection_name = p_collection_name ) loop  &lt;br/&gt;        l_xml := xmltype.createxml(c1.clob001);  &lt;br/&gt;        exit;  &lt;br/&gt;    end loop;  &lt;br/&gt;  &lt;br/&gt;    l_response := parse_xml(l_xml, p_xpath, p_ns);  &lt;br/&gt;  &lt;br/&gt;    return l_response;  &lt;br/&gt;  &lt;br/&gt;exception when others then  &lt;br/&gt;    if sqlcode = -31011 then -- its not xml  &lt;br/&gt;        return null;  &lt;br/&gt;    end if;  &lt;br/&gt;end parse_response;  &lt;br/&gt;  &lt;br/&gt;function parse_response_clob (  &lt;br/&gt;    p_collection_name   in varchar2,  &lt;br/&gt;    p_xpath             in varchar2,  &lt;br/&gt;    p_ns                in varchar2 default null ) return clob  &lt;br/&gt;is  &lt;br/&gt;    l_response          clob;  &lt;br/&gt;    l_xml               xmltype;  &lt;br/&gt;begin  &lt;br/&gt;  &lt;br/&gt;    for c1 in (select clob001  &lt;br/&gt;                 from apex_collections  &lt;br/&gt;                where collection_name = p_collection_name ) loop  &lt;br/&gt;        l_xml := xmltype.createxml(c1.clob001);  &lt;br/&gt;        exit;  &lt;br/&gt;    end loop;  &lt;br/&gt;  &lt;br/&gt;    l_response := parse_xml_clob(l_xml, p_xpath, p_ns);  &lt;br/&gt;  &lt;br/&gt;    return l_response;  &lt;br/&gt;  &lt;br/&gt;exception when others then  &lt;br/&gt;    if sqlcode = -31011 then -- its not xml  &lt;br/&gt;        return null;  &lt;br/&gt;    end if;  &lt;br/&gt;end parse_response_clob;  &lt;br/&gt;  &lt;br/&gt;end flex_ws_api;</source>
</body>
</PackageOracle>